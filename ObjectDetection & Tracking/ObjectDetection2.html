<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-time Object Detection & Tracking</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@latest"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #container {
            position: relative;
            border: 3px solid #333;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,255,0,0.3);
        }
        #video, #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 640px;
            height: 480px;
        }
        #canvas {
            pointer-events: none;
        }
        .controls {
            margin: 20px 0;
            display: flex;
            gap: 15px;
            align-items: center;
        }
        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            transition: all 0.3s;
        }
        button:hover { background: #45a049; }
        button:disabled { background: #666; cursor: not-allowed; }
        #stats {
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            min-width: 300px;
        }
        .track {
            background: rgba(255,255,255,0.1);
            padding: 5px 10px;
            margin: 3px 0;
            border-radius: 3px;
            font-family: monospace;
        }
        .fps { color: #4CAF50; font-weight: bold; }
    </style>
</head>
<body>
    <h1>üñ•Ô∏è Real-time Object Detection & Tracking</h1>
    
    <div id="container">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>
    </div>

    <div class="controls">
        <button id="startBtn">‚ñ∂Ô∏è Start Detection</button>
        <button id="stopBtn" disabled>‚èπÔ∏è Stop</button>
        <select id="confidence">
            <option value="0.5">Confidence: 50%</option>
            <option value="0.4">Confidence: 40%</option>
            <option value="0.3">Confidence: 30%</option>
            <option value="0.6">Confidence: 60%</option>
        </select>
        <div id="fps" class="fps">FPS: --</div>
    </div>

    <div id="stats">
        <div>üìä Tracked Objects: <span id="objectCount">0</span></div>
        <div id="trackList"></div>
    </div>

    <script>
        class ObjectTracker {
            constructor() {
                this.nextId = 0;
                this.tracks = new Map();
                this.maxAge = 30; // frames
                this.iouThreshold = 0.3;
                this.distanceThreshold = 100;
                this.fps = 0;
                this.frameCount = 0;
                this.lastTime = 0;
            }

            // Simple IOU calculation
            iou(box1, box2) {
                const x1 = Math.max(box1.x, box2.x);
                const y1 = Math.max(box1.y, box2.y);
                const x2 = Math.min(box1.x + box1.width, box2.x + box2.width);
                const y2 = Math.min(box1.y + box1.height, box2.y + box2.height);
                
                const intersection = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
                const union = box1.width * box1.height + box2.width * box2.height - intersection;
                return intersection / union;
            }

            // Euclidean distance between centers
            distance(box1, box2) {
                const cx1 = box1.x + box1.width / 2;
                const cy1 = box1.y + box1.height / 2;
                const cx2 = box2.x + box2.width / 2;
                const cy2 = box2.y + box2.height / 2;
                return Math.sqrt((cx1 - cx2)**2 + (cy1 - cy2)**2);
            }

            // Update tracks with new detections
            update(detections) {
                const newTracks = new Map();
                const matchedTracks = new Set();

                // Match existing tracks with new detections
                for (let [trackId, track] of this.tracks) {
                    let bestMatch = null;
                    let bestScore = 0;

                    for (let detection of detections) {
                        const iouScore = this.iou(track.lastBox, detection.bbox);
                        const distScore = 1 - Math.min(1, this.distance(track.lastBox, detection.bbox) / this.distanceThreshold);
                        const score = iouScore * 0.7 + distScore * 0.3;

                        if (score > bestScore && score > 0.4) {
                            bestScore = score;
                            bestMatch = detection;
                        }
                    }

                    if (bestMatch) {
                        track.lastBox = bestMatch.bbox;
                        track.age = 0;
                        track.class = bestMatch.class;
                        track.confidence = bestMatch.score;
                        newTracks.set(trackId, track);
                        matchedTracks.add(bestMatch);
                    } else {
                        track.age++;
                        if (track.age < this.maxAge) {
                            newTracks.set(trackId, track);
                        }
                    }
                }

                // Create new tracks for unmatched detections
                for (let detection of detections) {
                    if (!matchedTracks.has(detection)) {
                        const newTrack = {
                            id: this.nextId++,
                            lastBox: detection.bbox,
                            class: detection.class,
                            confidence: detection.score,
                            age: 0
                        };
                        newTracks.set(newTrack.id, newTrack);
                    }
                }

                this.tracks = newTracks;
                return Array.from(this.tracks.values());
            }
        }

        class DetectionApp {
            constructor() {
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.model = null;
                this.tracker = new ObjectTracker();
                this.isRunning = false;
                this.animationId = null;
                this.confidence = 0.5;

                this.setupEventListeners();
                this.resizeCanvas();
            }

            async setupEventListeners() {
                document.getElementById('startBtn').onclick = () => this.start();
                document.getElementById('stopBtn').onclick = () => this.stop();
                document.getElementById('confidence').onchange = (e) => {
                    this.confidence = parseFloat(e.target.value);
                };

                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                this.canvas.width = 640;
                this.canvas.height = 480;
            }

            async initModel() {
                this.model = await cocoSsd.load();
                console.log('COCO-SSD model loaded');
            }

            async start() {
                try {
                    await this.initModel();
                    
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { width: 640, height: 480 }
                    });
                    this.video.srcObject = stream;
                    
                    await new Promise(resolve => {
                        this.video.onloadedmetadata = () => {
                            this.video.play();
                            resolve();
                        };
                    });

                    this.isRunning = true;
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                    
                    this.detectLoop();
                } catch (error) {
                    console.error('Error starting detection:', error);
                    alert('Error accessing camera. Please check permissions.');
                }
            }

            stop() {
                this.isRunning = false;
                if (this.video.srcObject) {
                    this.video.srcObject.getTracks().forEach(track => track.stop());
                }
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                this.clearCanvas();
            }

            async detectLoop() {
                if (!this.isRunning) return;

                const now = performance.now();
                this.tracker.fps = Math.round(1000 / (now - this.tracker.lastTime));
                this.tracker.lastTime = now;
                this.updateStats();

                // Detect objects
                const predictions = await this.model.detect(this.video, this.confidence);
                
                // Filter and prepare detections
                const detections = predictions.map(pred => ({
                    bbox: {
                        x: pred.bbox[0],
                        y: pred.bbox[1],
                        width: pred.bbox[2],
                        height: pred.bbox[3]
                    },
                    class: pred.class,
                    score: pred.score
                })).filter(d => d.score > this.confidence);

                // Track objects
                const tracks = this.tracker.update(detections);

                // Render
                this.render(tracks);

                this.animationId = requestAnimationFrame(() => this.detectLoop());
            }

            render(tracks) {
                this.clearCanvas();
                
                // Draw tracks with bounding boxes and IDs
                tracks.forEach((track, index) => {
                    const box = track.lastBox;
                    const alpha = 1 - (track.age / this.tracker.maxAge);
                    
                    // Bounding box
                    this.ctx.strokeStyle = `rgba(0, 255, 0, ${alpha})`;
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(box.x, box.y, box.width, box.height);
                    
                    // Tracking ID background
                    this.ctx.fillStyle = `rgba(0, 255, 0, ${alpha * 0.7})`;
                    this.ctx.fillRect(box.x, box.y - 25, 80, 25);
                    
                    // Tracking ID text
                    this.ctx.fillStyle = 'black';
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(`ID:${track.id}`, box.x + 40, box.y - 8);
                    
                    // Class label
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = '14px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText(
                        `${track.class} (${Math.round(track.confidence * 100)}%)`, 
                        box.x, box.y + box.height + 20
                    );
                });
            }

            clearCanvas() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }

            updateStats() {
                document.getElementById('fps').textContent = `FPS: ${this.tracker.fps}`;
                document.getElementById('objectCount').textContent = this.tracker.tracks.size;
                
                const trackList = document.getElementById('trackList');
                trackList.innerHTML = '';
                
                Array.from(this.tracker.tracks.values())
                    .slice(0, 5)
                    .forEach(track => {
                        const div = document.createElement('div');
                        div.className = 'track';
                        div.textContent = `ID:${track.id} - ${track.class} (${Math.round(track.confidence*100)}%)`;
                        trackList.appendChild(div);
                    });
            }
        }

        // Initialize app
        const app = new DetectionApp();
    </script>
</body>
</html>
